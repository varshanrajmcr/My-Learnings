Methods of Primitives:
Use case: Wrapper objects give primitives methods.

let str = "hello";
console.log(str.toUpperCase()); // "HELLO"


Numbers:
Use case: Perform math operations or formatting.

let num = 3.14159;
console.log(num.toFixed(2)); // "3.14"


Strings:
Use case: Manipulate or check text.

let text = "JavaScript";
console.log(text.includes("Script")); // true


Arrays:
Use case: Store and access ordered data.

let arr = [1, 2, 3];
console.log(arr[1]); // 2


Array Methods:
Use case: Transform or search array elements.

let nums = [1, 2, 3];
console.log(nums.map(n => n * 2)); // [2, 4, 6]


Iterables:
Use case: Loop through iterable objects.

for (let ch of "Hi") console.log(ch); // H, i


Map and Set:
Use case: Store unique values or key/value pairs.

let map = new Map([["name", "John"]]);
console.log(map.get("name")); // John


WeakMap and WeakSet:
Use case: Store object keys without preventing garbage collection.

let weakMap = new WeakMap();
let obj = {};
weakMap.set(obj, "data");


Object.keys, values, entries:
Use case: Loop over object properties.

let user = {name: "John", age: 30};
console.log(Object.keys(user)); // ["name", "age"]


Destructuring Assignment:
Use case: Extract values easily.

let {name, age} = {name: "John", age: 30};
console.log(name); // John


Date and Time:
Use case: Work with dates.

let now = new Date();
console.log(now.getFullYear());


JSON Methods, toJSON:
Use case: Convert objects to/from JSON.

let user = {name: "John"};
console.log(JSON.stringify(user)); // '{"name":"John"}'
