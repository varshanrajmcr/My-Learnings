Recursion and Stack:
Use case: Solve problems by self-calling.

function factorial(n){ return n == 1 ? 1 : n * factorial(n - 1); }
console.log(factorial(5)); // 120


Rest Parameters and Spread Syntax:
Use case: Handle variable arguments.

function sum(...nums){ return nums.reduce((a,b)=>a+b); }
console.log(sum(1,2,3)); // 6


Variable Scope, Closure:
Use case: Remember outer variables inside inner function.

function makeCounter(){ let count=0; return ()=>++count; }
let counter = makeCounter();
console.log(counter()); // 1


The old var:
Use case: Function-scoped variable (legacy).

function test(){ var x = 1; console.log(x); }
test();


Global Object:
Use case: Access built-in globals.

console.log(window.Math === Math); // true (browser)


Function Object, NFE:
Use case: Named function expressions for recursion.

let sayHi = function hi() { console.log("Hi"); };
sayHi();


The "new Function" Syntax:
Use case: Create functions from strings dynamically.

let sum = new Function("a", "b", "return a + b");
console.log(sum(2,3)); // 5


Scheduling: setTimeout and setInterval:
Use case: Run code after delay or repeatedly.

setTimeout(()=>console.log("Hi later"), 1000);


Decorators and Forwarding (call/apply):
Use case: Extend function behavior.

function sayHi(){ console.log(this.name); }
sayHi.call({name: "John"});


Function Binding:
Use case: Fix this for callbacks.

let user = {name:"John", hi(){console.log(this.name);} };
setTimeout(user.hi.bind(user), 1000);


Arrow Functions Revisited:
Use case: Short syntax, no own this.

let user = {name:"Ilya", hi(){ setTimeout(()=>console.log(this.name),1000); }};
user.hi(); // Ilya
